Валидные данные:

Валидный e-mail с использованием максимального числа вариантов в локальной и доменной частях:
E-mail: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!#$%&'*+-/=?^_{|}~@abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!#$%&'*+-/=?^_{|}~

Валидный e-mail с использованием подадресации:
E-mail: user.subaddress@example.com

Валидный e-mail с регистром символов:
E-mail: User123@Example.Com

Валидный e-mail с использованием специальных символов:
E-mail: user!#$%&'*+-/=?^_{|}~-test@example.test`

Валидный e-mail с минимальной длиной:
E-mail: a@b.c

Валидный e-mail с использованием дефисов в доменной части:
E-mail: user@my-domain-example.com

Валидный e-mail с поддоменом:
E-mail: user@sub.example.com

Валидный e-mail с цифрами в локальной и доменной частях:
E-mail: user123@example123.com

Валидный e-mail с одним символом в локальной и доменной частях:
E-mail: a@b.c

Валидный e-mail с использованием точек в локальной части:
E-mail: user.name@example.com

Невалидные данные:

Невалидный e-mail без символа '@':
Некорректный e-mail: userexample.com

Невалидный e-mail с отсутствием локальной или доменной части:
Некорректный e-mail: @example.com или user@

Невалидный e-mail с использованием кавычек в некорректном месте:
Некорректный e-mail: "user.name"@example.com

Невалидный e-mail с множественными точками в доменной части:
Некорректный e-mail: user@example..com

Невалидный e-mail с пробелами:
Некорректный e-mail: user name@example.com

Невалидный e-mail без доменной части:
Некорректный e-mail: user@.com

Невалидный e-mail с запятой вместо точки:
Некорректный e-mail: user@domain,com

Невалидный e-mail с неверным форматом домена:
Некорректный e-mail: user@exa_mple.com

Невалидный e-mail с неверным расширением домена:
Некорректный e-mail: user@example.1234

Невалидный e-mail с использованием кириллических символов:
Некорректный e-mail: юзер@пример.ком

Пример кода в Spocke Framework

package com.xxx.bm: Это объявление пакета, в котором находится класс BackRefSpeck.

Импорты:

import
import

Аннотация @Epic('[NovoScript] Обратная ссылка'): Это аннотация от фреймворка Spock, которая помечает класс тестов как эпик и предоставляет краткое описание того, что тестируется.

class BackRefSpeck extends Specification: Этот класс наследует от Specification из Spock и представляет набор тестов.

Поля:

@Shared
def app = Application.COMPASS;

@Shared
String text = "Какой-то текст";
Здесь используется аннотация @Shared, чтобы поля app и text были общими для всех методов теста.

Метод тестирования:

def "Простой тест на обратную ссылку" () {
    given:
        SetupUtil.chekSqlThenSetup(app)

    when: "создание объектов модели"
        def kredPers = new PltfmReference('6781234567896', 'KRED_PERS') as PltfmReference
        def classList = kredPers.getBackReference()

    then: "проверка того что все создано"
        classList.find{it.getRefClass() == 'FIN_ORDER' } != null

    when: "вызываем конструктор"
        def backRefOrder =+classList.find{it.getRefClass() == 'FIN_ORDER' } as PltfmBackReference

    then:
        backRefOrder.getListDataInView('VM_CRIT_FULL_FIN_ORDER').size() > 0

    cleanup:
        CleanUtil.safeCallCompassRollBack (app)
}

given: содержит предусловия для теста.
when: описывает действия, которые происходят в тесте.
then: определяет ожидаемые результаты.
cleanup: указывает на действия, которые следует выполнить после завершения теста, в данном случае, это очистка.
============================================================================================================================

@Epic ('Анотация')
class ИмяКласса extends Specification {

  @Shared
	def app = Application.COMPASS

	def "Подключение к БД. Проверка данных в справочнике XXX_XXX_CODES"() {
      given:
        SetupUtil.chekSqlThenSetup(app)
        def vwXxxXxxCodes  = app.XXX_XXX_CODES.VW_CRIT_XXX_XXX_CODES as PltfmView

      when: "Запрос к БД"
           def dbResult = vwXxxXxxCodes.rows("SELECT C_1, C_2, C_3, C_5 FROM XXX_XXX_CODES")

           // Определение пути к JSON
           def jsonFilePath = 'name.JSON'
           // Загрузка данных в переменную json
           def json = new JsonSlurper().parse(new File(jsonFilePath))

      then: "Проверка соответствия данных"
           // Проверка, что количество записей в БД и JSON файле совпадает
           assert dbResult.size() == jsonsize() : "Количество записей в БД не соответствует количеству записей в JSON файле."

           // Проверка соответствия каждой записи
           assert dbResult.every { row ->
              json.any { it.KindName_1 == row.C_1 && it.KindName_2 == row.C_2 && it.KindName_3 == row.C_3 && it.KindName_5 == row.C_5 && }
           } : "Данные в БД не соответствуют данным из JSON файла."

		  cleanup:
			CleanUtil.safeCallCompassRollBack (app)
	}
}

